## distribution-uniformity

从你给出的这组 Layout 和 Metrics 信息来看，整体上是合理的，主要原因如下：

三个立方体在同一条水平线 (x=65) 上排布，依次沿 y 方向排开

Cuboid1：中心点 y=60，尺寸 (130×120)；
Cuboid2：中心点 y=180，尺寸 (130×120)；
Cuboid3：中心点 y=300，尺寸 (130×120)。
每个立方体的「depth=120」意味着它在 y 方向各自占据 120 的长度，因此三个立方体恰好按 y=0120、120240、240~360 的段落向上排布；
也就是说，它们几乎形成了“竖直方向上连续且无重叠”的三个大块。
gridVariance（标准差约 0.473）

由于三个立方体在 x 方向上重叠几乎一致，水平方向的覆盖分布很均匀；
但在 y 方向上则分成三段，且最上方的立方体顶部 y=360，已经超出 300×300 的区域一部分（300~360 这段）。
这样一来，网格的实际覆盖就大约前 8 行（或 8.5 行）的格子覆盖率几乎是 1，最后可能有一行或两行格子要么完全覆盖不到，要么覆盖率部分<1。
最终导致“覆盖率的标准差”并不特别大，但也谈不上特别小——0.47 左右就属于“中等程度”的离散度。
densityChange（约 0.1053）

这是相邻格子间覆盖率的差值平均。
水平方向基本上覆盖率都差不多（因为同一个 cuboid 占据了大部分 x 范围），不会有太大跳变；
垂直方向上，只会在“分段交接处”出现从高覆盖到低覆盖的跳变，但只有两个交接处 (y≈120 和 y≈240)，加在所有网格之间平均一下，变动就不会很大。
所以得到一个相对较小的值（约 0.105），说明整体分布除了段与段交界处，其余地方的覆盖差异较平缓。
clusterIndex = 1

你的计算逻辑里，clusterIndex 越小表示立方体之间距离越大、分布越分散；值越大表示它们挤在一起。
但是函数最后返回
min
⁡
(
1
,
1
/
某距离比
)
min(1,1/某距离比)，如果立方体彼此中心相距较远，那么“距离比”会很大，
1
/
large
1/large 就会很小；
当这个值被限制成
min
⁡
(
1
,
.
.
.
)
min(1,...) 后，如果实际算下来可能 < 1，又因为你取了
min
⁡
(
1
,
1
/
avgRatio
)
min(1,1/avgRatio)，有可能最终被“截断”成 1；也可能确实恰好处于某个边界情况。
在三个立方体已经几乎“首尾相接”排开的情况下，中心之间的距离其实不是很大，所以导致
avgRatio
avgRatio 并不算很大，最终
min
⁡
(
1
,
1
/
avgRatio
)
min(1,1/avgRatio) 却得到 1。
这往往意味着**“你定义的上限”** 达到了——或者说此时距离并不算特别远，却由于公式被截断到 1（表示它们还是有一定程度的“接近”）。
如果你希望它能返回更接近 0 来表示“距离很大”，那就要检查下你对距离和体积的归一化公式；若想让真实远距能反映到更小的数值，可以把“
min
⁡
(
1
,
.
.
.
)
min(1,...)” 去掉，或换成别的映射方式。
Final Score ≈ 58.06

根据你在 getDistributionUniformityScore 中的权重和映射方式，此时给出的分数并不高，大概在**“中等偏下”**的水平。
这也符合直觉：它们虽然在 x 方向基本对齐，但从 0360 分三大段，所以从 0300 范围内看来，最顶部(300~360)部分对整体分布的均匀性有一点影响；加之只有三个大块，并不是细碎均匀的分布。
所以打个 50~60 左右的分数，很正常。
综上，你的 Layout、Metrics 和最终 Score 的调试输出在逻辑上是合理的。如果在业务上你觉得“这一种排布应该分数再高/再低一点”，则可以在 distribution-uniformity.ts 里微调映射公式或权重，让它更符合你的“主观需求”。但就代码本身的计算结果来说，这样的数值表现是可以自洽的。
